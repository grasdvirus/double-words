/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for profile data and leaderboard entries,
 * and a shared-access model for duel games.  It prioritizes preventing unauthorized data
 * modification and access. Data shape is not strictly enforced in this prototype.
 *
 * Data Structure:
 * - /users/{userId}: Stores public profile information for each user.
 * - /leaderboard/{userId}: Stores leaderboard entries for each user.
 * - /duels/{duelId}: Stores duel game sessions.
 * - /duelGameCodes/{gameCode}: Maps game codes to duel IDs for easy joining.
 *
 * Key Security Decisions:
 * - Users can only modify their own profile and leaderboard entries.
 * - Duel games have a host who initiates the game, and other players can join.
 * - Listing all users is disallowed.
 * - 'duelGameCodes' collection exposes 'duelId' to anyone who knows the 'gameCode'.
 *
 * Denormalization for Authorization:
 * - Duel documents contain a `hostId` field for easy ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (create) User with UID 'test_user' can create their own profile document.
     *   Request: { "auth": { "uid": "test_user" }, "resource": { "data": { "id": "test_user", "displayName": "Test User" } } }
     * @allow (update) User with UID 'test_user' can update their own profile document.
     *   Request: { "auth": { "uid": "test_user" }, "resource": { "data": { "id": "test_user", "displayName": "Updated User" } } }
     * @deny (create) User with UID 'other_user' cannot create a profile for 'test_user'.
     *   Request: { "auth": { "uid": "other_user" }, "resource": { "data": { "id": "test_user", "displayName": "Test User" } } }
     * @deny (update) User with UID 'other_user' cannot update the profile for 'test_user'.
     *   Request: { "auth": { "uid": "other_user" }, "resource": { "data": { "id": "test_user", "displayName": "Updated User" } } }
     * @principle Enforces document ownership for writes and read-only access for others.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to leaderboard entries.
     * @path /leaderboard/{userId}
     * @allow (create) User with UID 'test_user' can create their own leaderboard entry.
     *   Request: { "auth": { "uid": "test_user" }, "resource": { "data": { "displayName": "Test User", "score": 100, "updatedAt": "2024-01-01T00:00:00Z" } } }
     * @allow (update) User with UID 'test_user' can update their own leaderboard entry.
     *   Request: { "auth": { "uid": "test_user" }, "resource": { "data": { "displayName": "Updated User", "score": 200, "updatedAt": "2024-01-02T00:00:00Z" } } }
     * @deny (create) User with UID 'other_user' cannot create a leaderboard entry for 'test_user'.
     *   Request: { "auth": { "uid": "other_user" }, "resource": { "data": { "displayName": "Test User", "score": 100, "updatedAt": "2024-01-01T00:00:00Z" } } }
     * @deny (update) User with UID 'other_user' cannot update the leaderboard entry for 'test_user'.
     *   Request: { "auth": { "uid": "other_user" }, "resource": { "data": { "displayName": "Updated User", "score": 200, "updatedAt": "2024-01-02T00:00:00Z" } } }
     * @principle Enforces document ownership for writes and read-only access for others.
     */
    match /leaderboard/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to duel game sessions.
     * @path /duels/{duelId}
     * @allow (create) User with UID 'test_user' can create a new duel game.
     *   Request: { "auth": { "uid": "test_user" }, "resource": { "data": { "hostId": "test_user", "status": "waiting", "players": [], "createdAt": "2024-01-01T00:00:00Z" } } }
     * @allow (update) Host 'test_user' can update the duel game.
     *   Request: { "auth": { "uid": "test_user" }, "resource": { "data": { "hostId": "test_user", "status": "active" } } }
     * @deny (update) Non-host 'other_user' cannot update the duel game.
     *   Request: { "auth": { "uid": "other_user" }, "resource": { "data": { "hostId": "test_user", "status": "active" } } }
     * @principle Enforces host-based ownership for game management.
     */
    match /duels/{duelId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwnerDuel(resource.data.hostId);
      allow delete: if isSignedIn() && isExistingOwnerDuel(resource.data.hostId);
    }

    /**
     * @description Controls access to duel game code mappings.
     * @path /duelGameCodes/{gameCode}
     * @allow (get) Anyone can retrieve a duel ID by knowing the game code.
     *   Request: { "auth": null, "method": "get", "path": "/databases/(default)/documents/duelGameCodes/E8H86E" }
     * @deny (create) No one is allowed to write to this collection directly
     * @deny (update) No one is allowed to write to this collection directly
     *
     * @principle Allows public read access to duel IDs based on game codes.
     */
    match /duelGameCodes/{gameCode} {
      allow get: if true;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }

  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

    function isExistingOwner(userId) {
    return isSignedIn() && isOwner(userId) && resource != null;
  }

  function isExistingOwnerDuel(hostId) {
    return isSignedIn() && request.auth.uid == hostId && resource != null;
  }
}